// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FillTree

#include "UnityCG.cginc"

CBUFFER_START(VoxelData)
int IndexCount;
int VoxelCount;
int MaxDepth;
CBUFFER_END

struct VoxelOctreeNode 
{
	int Index;
	int CurrentDepth;
	int FirstChild;
	int Parent;
	int FirstLeaf;
	int LastLeaf;
	float3 Position;
	float Size;
	int Value;
};

RWStructuredBuffer<VoxelOctreeNode> VoxelOctreeBuffer;

RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> IndexBuffer;

float2 GetBoxInterval(float3 boxCenter, float3 boxSize, float3 axis)
{
	float2 interval;

	float3 p1 = boxCenter - boxSize / 2.0;
	float3 p2 = boxCenter + boxSize / 2.0;

	float3 minP = p1;//float3(min(p1.x, p2.x), min(p1.y, p2.y), min(p1.z, p2.z));
	float3 maxP = p2;//float3(max(p1.x, p2.x), max(p1.y, p2.y), max(p1.z, p2.z));

	float3 v0 = float3(minP.x, maxP.y, maxP.z);
	float3 v1 = float3(minP.x, maxP.y, minP.z);
	float3 v2 = float3(minP.x, minP.y, maxP.z);
	float3 v3 = float3(minP.x, minP.y, minP.z);
	float3 v4 = float3(maxP.x, maxP.y, maxP.z);
	float3 v5 = float3(maxP.x, maxP.y, minP.z);
	float3 v6 = float3(maxP.x, minP.y, maxP.z);
	float3 v7 = float3(maxP.x, minP.y, minP.z);

	float mn = 99999999;
	float mx = -99999999;

	float projection = dot(axis, v0);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v1);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v2);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v3);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v4);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v5);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v6);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(axis, v7);

	mn = min(mn, projection);
	mx = max(mx, projection);

	interval.x = mn;
	interval.y = mx;

	return interval;
}

float2 GetTriangleInterval(float3 tri0, float3 tri1, float3 tri2, float3 axis)
{
	float2 interval;

	float mn = 999999999;
	float mx = -999999999;

	float projection = dot(tri0, axis);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(tri1, axis);

	mn = min(mn, projection);
	mx = max(mx, projection);

	projection = dot(tri2, axis);

	mn = min(mn, projection);
	mx = max(mx, projection);

	interval.x = mn;
	interval.y = mx;

	return interval;
}

int OverlapAxis(float3 tri0, float3 tri1, float3 tri2, float3 boxCenter, float3 boxSize, float3 axis)
{
	float2 a = GetBoxInterval(boxCenter, boxSize, axis);
	float2 b = GetTriangleInterval(tri0, tri1, tri2, axis);

	if (((b.x <= a.y) && (a.x <= b.y)))
	{
		return 1;
	}
	return 0;
}

int TriangleBoxIntersection(float3 tri0, float3 tri1, float3 tri2, float3 boxCenter, float3 boxSize)
{
	float3 triangleEdge0 = tri1 - tri0;
	float3 triangleEdge1 = tri2 - tri1;
	float3 triangleEdge2 = tri0 - tri2;

	float3 boxNormal0 = float3(1, 0, 0);
	float3 boxNormal1 = float3(0, 1, 0);
	float3 boxNormal2 = float3(0, 0, 1);

	float3 triangleNormal = cross(triangleEdge0, triangleEdge1);

	float3 a0 = float3(0, -triangleEdge0.z, triangleEdge0.y);
	float3 a1 = float3(0, -triangleEdge1.z, triangleEdge1.y);
	float3 a2 = float3(0, -triangleEdge2.z, triangleEdge2.y);
	float3 a3 = float3(triangleEdge0.z, 0, -triangleEdge0.x);
	float3 a4 = float3(triangleEdge1.z, 0, -triangleEdge1.x);
	float3 a5 = float3(triangleEdge2.z, 0, -triangleEdge2.x);
	float3 a6 = float3(-triangleEdge0.y, triangleEdge0.x, 0);
	float3 a7 = float3(-triangleEdge1.y, triangleEdge1.x, 0);
	float3 a8 = float3(-triangleEdge2.y, triangleEdge2.x, 0);

	if (OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, boxNormal0) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, boxNormal1) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, boxNormal2) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, triangleNormal) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a0) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a1) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a2) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a3) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a4) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a5) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a6) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a7) == 0 ||
		OverlapAxis(tri0, tri1, tri2, boxCenter, boxSize, a8) == 0)
	{
		return 0;
	}

	return 1;
}

[numthreads(8, 1, 1)]
void FillTree(uint3 id : SV_DispatchThreadID) 
{
	if (id.x >= IndexCount / 3)
	{
		return;
	}

	int index = id.x * 3;
	int i0 = IndexBuffer[index + 0];
	int i1 = IndexBuffer[index + 1];
	int i2 = IndexBuffer[index + 2];

	float3 v0 = VertexBuffer[i0];
	float3 v1 = VertexBuffer[i1];
	float3 v2 = VertexBuffer[i2];

	int min = 0;

	for (int i = 0; i <= MaxDepth - 1; i++)
	{
		min += (int)pow(8, i);
	}

	for (int i = min; i < VoxelCount;)
	{
		int parentIndex = VoxelOctreeBuffer[i].Parent;
		int lastSkip = 0;
		while (parentIndex >= 0)
		{
			int intersecting = TriangleBoxIntersection(v0, v1, v2, VoxelOctreeBuffer[parentIndex].Position, float3(VoxelOctreeBuffer[parentIndex].Size, VoxelOctreeBuffer[parentIndex].Size, VoxelOctreeBuffer[parentIndex].Size));

			if (intersecting == 1)
			{
				break;
			}
			else
			{
				lastSkip = VoxelOctreeBuffer[parentIndex].LastLeaf;
				parentIndex = VoxelOctreeBuffer[parentIndex].Parent;
			}
		}

		if (lastSkip == 0)
		{
			for (int j = i; j < i + 8; j++)
			{
				int intersecting = TriangleBoxIntersection(v0, v1, v2, VoxelOctreeBuffer[j].Position, float3(VoxelOctreeBuffer[j].Size, VoxelOctreeBuffer[j].Size, VoxelOctreeBuffer[j].Size));

				if (intersecting == 1)
				{
					/*if (VoxelOctreeBuffer[j].Value == 0)
					{
						FilledNodes.Add(VoxelOctreeBuffer[j]);
					}*/

					VoxelOctreeBuffer[j].Value = 1;
				}
			}

			i += 8;
		}
		else
		{
			i = lastSkip + 1;
		}
	}
}